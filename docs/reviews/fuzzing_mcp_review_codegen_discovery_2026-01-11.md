# Review: fuzz target discovery + validation (edge cases)

Generated by an MCP Codex DAG review job (`454b2e8c99cb6971`) on 2026-01-11 and checked into the repo as a durable reference.

# Fuzz Target Discovery + Validation Review (Edge Cases)

Scope: `tools/src/discovery.cpp`, `tools/src/discovery.hpp`, `tools/src/validate.cpp`, `tools/src/parse.cpp`, `tools/src/model.hpp`, `tools/src/main.cpp` (plus `tools/src/emit.cpp`, `tools/src/parse_core.cpp` where behavior is consumed by fuzz flow).

## 1) Silent drops / weak diagnostics

- **Not in main file**: `TestCaseCollector::run` drops any function whose begin location is not in the main file (via `isWrittenInMainFile`), with no diagnostic. This means fuzz targets defined in headers (even if included) are ignored silently. (`tools/src/discovery.cpp`)
- **Attribute adjacency requirement**: `scan_attributes_before` only collects attributes that are *immediately* adjacent to the declaration (allowing only whitespace/comments). If a specifier (`static`, `inline`, `constexpr`), preprocessor directive, or macro expansion sits between the attribute and the declaration, the attribute is missed with no error. (`tools/src/parse.cpp`)
- **Macro-based attributes**: attribute text is scanned from the raw file buffer, not the preprocessed buffer; `[[using gentest: ...]]` introduced via macros can be invisible to `scan_attributes_before`, causing silent drops. (`tools/src/parse.cpp`)
- **Parse errors are ignored**: `parse_attribute_list` ignores unknown syntax segments; malformed attribute lists can result in empty/partial parse without diagnostics. This can make a fuzz target appear “undiscovered” rather than failing clearly. (`tools/src/parse_core.cpp`, consumed by `tools/src/parse.cpp`)
- **Anonymous namespace**: fuzz targets in anonymous namespaces are ignored with a warning, but this is not a hard error; in CI, warnings may be missed. (`tools/src/discovery.cpp`)
- **No fuzz output requested**: if `--fuzz-output` is omitted, fuzz targets are discovered but never emitted; there is no warning or error (unless a fuzz backend is explicitly set with targets). (`tools/src/main.cpp`, `tools/src/emit.cpp`)

## 2) Signature detection robustness (libstdc++/libc++)

- **`std::span` name check is too strict**: `is_std_span_of_const_u8` matches only `std::span` via `getQualifiedNameAsString() == "std::span"`. With libc++ inline namespaces (`std::__1::span`, `std::__2::span`), this check can fail. The signature then falls back to “Typed”, which can produce bad FuzzTest registrations. (`tools/src/discovery.cpp`)
- **`uint8_t`-only assumption**: `is_u8_like` accepts only builtin `unsigned char`. It rejects `std::byte` and any non-`unsigned char` 8-bit type. That can prevent `std::span<const std::byte>` and `(std::byte*, size_t)` signatures from being recognized as byte-based fuzz targets. (`tools/src/discovery.cpp`)
- **Pointer+size mismatch diagnostics**: if the pointer matches `const uint8_t*` but the size parameter is not `size_t` (or a type canonical to it), the error reported is about *raw pointers*, not about the size type mismatch. That can confuse users. (`tools/src/discovery.cpp`)

## 3) Collisions from suite/test sanitization

- **Sanitized-name collisions aren’t checked**: for FuzzTest output, suite/test names are sanitized by replacing non-alnum with `_`. Different `display_name` values can collapse to the same sanitized `(suite,test)` pair, causing duplicate registrations without detection. (`tools/src/emit.cpp`)
- **Split-at-last-`/` behavior**: `display_name` is split by the last `/`. Any additional `/` in `suite` or `case_name` (or in a `suite(...)` attribute) affects how suite/test are sanitized and can create collisions not caught by the `final_base` uniqueness check. (`tools/src/discovery.cpp`, `tools/src/emit.cpp`)

## 4) Templates, overloads, namespaces, static

- **Function templates**: fuzz targets allow template functions implicitly (no explicit rejection), but wrappers call `qualified_name` without template arguments. This will fail to compile for function templates or require ADL to pick a specialization (unlikely). (`tools/src/discovery.cpp`, `tools/src/emit.cpp`)
- **Overloads**: wrapper calls are direct, with parameter types spelled from AST; overload resolution should succeed when the signature is exact. However, if overloads are templated or require conversions, ambiguity could appear at codegen time with no earlier error. (`tools/src/discovery.cpp`, `tools/src/emit.cpp`)
- **Static member functions**: all member functions (including `static`) are rejected for fuzz targets, even though static members could be callable without an instance. This is a deliberate limitation but not explicitly documented in diagnostics beyond “member functions not supported.” (`tools/src/discovery.cpp`)
- **Namespaces**: anonymous namespaces are ignored with warnings. Inline namespaces are included in the derived suite path, which may make suite names unstable across compiler/lib settings unless explicitly overridden with `suite(...)`. (`tools/src/discovery.cpp`)

## 5) Future fuzz attributes (domains, seeds, corpus)

- **Strict allowlist**: any new attribute name (with args) will be a hard error until added to validation rules. This blocks forward-compatible use. (`tools/src/validate.cpp`)
- **Model lacks fuzz config**: `FuzzTargetInfo` has no fields for fuzzing config (domains, seeds, corpus, etc.). Adding attributes will require expanding `AttributeSummary`, `FuzzTargetInfo`, and render logic. (`tools/src/model.hpp`, `tools/src/discovery.cpp`, `tools/src/emit.cpp`)
- **Namespace/class scope**: namespace and class validators reject unknown attributes as errors. If future fuzz config is intended to be set at namespace level (e.g., per-suite corpus), this must be added explicitly. (`tools/src/validate.cpp`)

## 6) Recommended improvements (minimal patch ideas)

- **Span detection portability**: accept `std::span` in inline namespaces by checking `TemplateDecl::getNameAsString() == "span"` and that its parent is `std` (or name ends with `::span`). Also allow `std::byte` as a byte element type. (`tools/src/discovery.cpp`)
- **Explicit fuzz template rejection**: if `FunctionDecl` is a function template (or has a described template), emit a clear error: “fuzz targets cannot be function templates.” Prevents late compile errors. (`tools/src/discovery.cpp`)
- **Better diagnostics for size mismatch**: when a `(ptr, len)` signature is detected but `len` is not `size_t`, emit a specific error about the length parameter type. (`tools/src/discovery.cpp`)
- **Detect sanitized collisions**: compute sanitized `(suite,test)` for each fuzz target during discovery or emit; if a collision occurs, emit an error and list both display names/locations. (`tools/src/emit.cpp` or during `TestCaseCollector::run`)
- **Surface silent drops**: add warnings (or opt-in strict errors) when a `gentest` attribute is seen but the function is skipped due to `isWrittenInMainFile`, macro-based attribute placement, or anonymous namespace. (`tools/src/discovery.cpp`, `tools/src/parse.cpp`)
- **Future fuzz attributes**: add a `FuzzTargetConfig` in `model.hpp`, parse/validate `domain`, `seed`, `corpus` (likely as value attributes), and merge namespace defaults with per-function overrides. This keeps validation strict but extensible. (`tools/src/model.hpp`, `tools/src/validate.cpp`, `tools/src/discovery.cpp`, `tools/src/emit.cpp`)

---

If you want, I can follow up with a concrete patch plan (file-by-file changes + expected diagnostics) without modifying the repo.
