# Review: fuzz target emission (FuzzTest backend)

Generated by an MCP Codex DAG review job (`454b2e8c99cb6971`) on 2026-01-11 and checked into the repo as a durable reference.

# Review: Fuzz target emission (FuzzTest backend)

Scope: `tools/src/emit.cpp`, `tools/src/templates.hpp`, `include/gentest/attributes.h`, `cmake/CheckNoFuzztestLeak.cmake`.
Focus: correctness + non‑leakage of FuzzTest codegen TU.

## Findings (ordered by severity)

### 1) **Potential incompatibility with common FuzzTest installs due to internal headers**
- **Where:** `tools/src/templates.hpp` (`fuzztest_impl` includes `<fuzztest/internal/registration.h>` and `<fuzztest/internal/registry.h>`).
- **Risk:** Many FuzzTest packages expose only public headers (e.g., `fuzztest/fuzztest.h`). The `internal/` headers are not part of the stable, supported API and may be absent or change across versions, leading to build failures even when FuzzTest is installed.
- **Impact:** Generated TU may not compile on standard FuzzTest installs or across version updates.
- **Minimal patch idea:** Replace the internal includes with the public FuzzTest header and register via public API (e.g., `FUZZ_TEST` macro or public registration helpers). If direct registration is required, add `#if __has_include` fallback to public header first, and only use internal headers as an opt‑in fallback. Keep wrappers in the anonymous namespace and use the macro to register them.

### 2) **Name sanitization can create collisions for fuzz registrations**
- **Where:** `tools/src/emit.cpp` (`sanitize_gtest_name` + `suite_name`/`test_name` assignment; registration uses only sanitized suite/test strings).
- **Risk:** Different `display_name` values can sanitize to identical `suite/test` (e.g., `a-b` vs `a b`, unicode, punctuation differences), producing duplicate registrations. FuzzTest’s registry may treat duplicates as errors or last‑one‑wins depending on version.
- **Impact:** Potential loss of targets or runtime errors due to duplicate keys.
- **Minimal patch idea:** Incorporate a disambiguator (e.g., `idx`, `line`, or a hash suffix) into the registered test name when sanitization changes the original or when duplicates are detected in codegen. Keep display name intact for reporting elsewhere if needed.

### 3) **Typed wrapper parameter handling relies on FuzzTest’s domain support**
- **Where:** `tools/src/emit.cpp` (typed path, `param_list` built from `target.parameter_types`).
- **Risk:** The generated wrapper mirrors parameter types verbatim. If the signature uses types that FuzzTest does not provide a domain for (e.g., certain `string_view`/custom types/`const&` to non‑domain types), registration will compile but may fail to link or fail at runtime with domain errors. This is not checked in the emitter.
- **Impact:** Target registers but fails to execute or compile depending on type support.
- **Minimal patch idea:** Add a generated static_assert or helper trait check (in the generated TU) that validates each parameter type is `fuzztest::Domain<T>`‑constructible (or the relevant FuzzTest compatibility trait), emitting a clear compile error early.

## Correctness notes

### Span vs ptr+size wrappers
- **Span path:** Wrapper takes `std::vector<std::uint8_t>` by value and constructs `std::span<const std::uint8_t>` for `BytesSpan`. This is correct and avoids raw pointer exposure. It relies on FuzzTest providing a domain for `std::vector<uint8_t>`.
- **Ptr+size path:** Wrapper passes `data.data()` and `data.size()` for `BytesPtrSize`. This is correct for `const uint8_t*`/`size_t`. `data.data()` is valid even when size is 0; no UB.
- **Typed path:** Wrapper forwards arguments as-is. Correct if parameter types are FuzzTest‑compatible. No implicit decay or const‑stripping occurs; that is good for type fidelity but can expose unsupported types.

### Registration mechanics
- **Where:** `emit.cpp` (registration lambda using `::fuzztest::RegisterFuzzTest(::fuzztest::GetRegistration<decltype(+wrapper)>(...))`).
- **Observation:** This is a low‑level registration path and almost certainly tied to `internal/` headers. It will be brittle across FuzzTest versions.
- **Uniqueness:** Unique wrapper names use `idx`, but registry keys are only `suite/test` strings. No enforcement of uniqueness exists at generation time.

## Non‑leakage assessment

- **Public headers:** `include/gentest/attributes.h` is documentation‑only and does not include or reference FuzzTest headers. No leak there.
- **Generated TU:** FuzzTest headers appear only in `fuzztest_impl` template. This is good *provided* the fuzz TU is compiled only for fuzz builds. If this TU is accidentally added to non‑fuzz targets, FuzzTest becomes a required dependency.
- **CMake leak check:** `cmake/CheckNoFuzztestLeak.cmake` performs a substring scan, which can catch leakage when pointed at install/include trees. It does not, by itself, prevent the generated fuzz TU from being built in non‑fuzz targets—this depends on how build targets wire the generated file.

## Recommended improvements (no code changes here)

1) **Move to public FuzzTest API.** Use `#include <fuzztest/fuzztest.h>` and register via `FUZZ_TEST` (or other public API) instead of `internal/*` headers. If internal API is required for flexibility, wrap it with `#if __has_include` so common installs work.
2) **Avoid name collisions.** Add a suffix (e.g., `_L<line>` or `_I<idx>`) to the registered test name when sanitization changes the original or when duplicates are detected during emission.
3) **Type compatibility checks.** Emit a compile‑time check per typed target (static_assert) to ensure FuzzTest domain support for each parameter type, providing actionable errors.
4) **Guard fuzz TU inclusion.** Ensure the generated fuzz TU is only compiled when FuzzTest is enabled, and confirm `CheckNoFuzztestLeak.cmake` is run against exported headers/installed artifacts (not just sources).

## Direct answers to questions

- **Does generated code compile across common FuzzTest installs?** Not reliably, because it includes `fuzztest/internal/*` headers and uses internal registration APIs; these are not guaranteed to ship with packaged installs. Switching to public headers/macros would improve compatibility.
- **Wrapper correctness for span vs ptr+size vs typed targets?** Span and ptr+size wrappers are correct and safe with `std::vector<uint8_t>` as the fuzz input type. Typed wrapper correctness depends on FuzzTest’s domain support for the exact parameter types; no checks exist.
- **Registry naming and uniqueness?** Wrapper functions are unique (`idx`), but registry keys rely on sanitized suite/test names and can collide after sanitization.
- **Chance of fuzztest headers leaking into public headers or non‑fuzz builds?** Public headers are clean. Leak risk is confined to the generated fuzz TU; it is safe if that TU is only compiled for fuzz targets. The CMake substring scan can enforce this for installed headers but does not automatically prevent mis‑wiring.
