// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#include <array>
#include <exception>
#include <iostream>
#include <span>
#include <string_view>
#include <vector>

#include "gentest/runner.h"

{{FORWARD_DECLS}}
namespace {

{{TRAIT_DECLS}}

struct Case {
    std::string_view                  name;
    void (*fn)();
    std::string_view                  file;
    unsigned                          line;
    std::span<const std::string_view> tags;
    std::span<const std::string_view> requirements;
    std::string_view                  skip_reason;
    bool                              should_skip;
};

constexpr std::array<Case, {{CASE_COUNT}}> kCases = {
{{CASE_INITS}}
};
} // namespace

namespace {
bool wants_list(std::span<const char*> args) {
    for (const auto* arg : args) {
        if (arg != nullptr && std::string_view(arg) == "--list") {
            return true;
        }
    }
    return false;
}
} // namespace

auto {{ENTRY_FUNCTION}}(std::span<const char*> args) -> int {
    if (wants_list(args)) {
        for (const auto& test : kCases) {
            std::cout << test.name;
            bool first_section = true;
            if (!test.tags.empty() || !test.requirements.empty() || test.should_skip) {
                std::cout << " [";
                if (!test.tags.empty()) {
                    std::cout << "tags=";
                    for (std::size_t idx = 0; idx < test.tags.size(); ++idx) {
                        if (idx != 0) {
                            std::cout << ',';
                        }
                        std::cout << test.tags[idx];
                    }
                    first_section = false;
                }
                if (!test.requirements.empty()) {
                    if (!first_section) {
                        std::cout << ';';
                    }
                    std::cout << "requires=";
                    for (std::size_t idx = 0; idx < test.requirements.size(); ++idx) {
                        if (idx != 0) {
                            std::cout << ',';
                        }
                        std::cout << test.requirements[idx];
                    }
                    first_section = false;
                }
                if (test.should_skip) {
                    if (!first_section) {
                        std::cout << ';';
                    }
                    std::cout << "skip";
                    if (!test.skip_reason.empty()) {
                        std::cout << '=' << test.skip_reason;
                    }
                }
                std::cout << ']';
            }
            std::cout << " (" << test.file << ':' << test.line << ")\n";
        }
        return 0;
    }

    std::size_t executed = 0;
    int failures = 0;
    for (const auto& test : kCases) {
        if (test.should_skip) {
            std::cout << "[ SKIP ] " << test.name;
            if (!test.skip_reason.empty()) {
                std::cout << " :: " << test.skip_reason;
            }
            std::cout << "\n";
            continue;
        }
        ++executed;
        try {
            test.fn();
            std::cout << "[ PASS ] " << test.name << "\n";
        } catch (const gentest::failure& err) {
            ++failures;
            std::cerr << "[ FAIL ] " << test.name << " :: " << err.what() << "\n";
        } catch (const std::exception& err) {
            ++failures;
            std::cerr << "[ FAIL ] " << test.name << " :: unexpected std::exception: " << err.what() << "\n";
        } catch (...) {
            ++failures;
            std::cerr << "[ FAIL ] " << test.name << " :: unknown exception" << "\n";
        }
    }

    if (failures == 0) {
        std::cout << "Executed " << executed << " test(s).\n";
    } else {
        std::cerr << "Executed " << executed << " test(s) with " << failures << " failure(s).\n";
    }
    return failures == 0 ? 0 : 1;
}

auto {{ENTRY_FUNCTION}}(int argc, char** argv) -> int {
    std::vector<const char*> args;
    args.reserve(static_cast<std::size_t>(argc));
    for (int i = 0; i < argc; ++i) {
        args.push_back(argv[i]);
    }
    return {{ENTRY_FUNCTION}}(std::span<const char*>{args.data(), args.size()});
}
