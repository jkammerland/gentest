// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#include <array>
#include <exception>
#include <string>
#include <fmt/core.h>
#include <random>
#include <algorithm>
#include <type_traits>
#include <span>
#include <string_view>
#include <vector>

#include "gentest/runner.h"
#include "gentest/fixture.h"

// Include test sources so fixture types are visible for wrappers
{{INCLUDE_SOURCES}}

{{FORWARD_DECLS}}
namespace {

{{TRAIT_DECLS}}

// Per-case invocation wrappers. All wrappers use a uniform signature
//   void(void* ctx)
// Free tests ignore ctx; ephemeral fixtures construct a new instance per call;
// stateful fixtures expect ctx to point to the shared fixture instance.
template <typename T>
inline void __gentest_maybe_setup(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureSetup, T>) t.setUp();
}

template <typename T>
inline void __gentest_maybe_teardown(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureTearDown, T>) t.tearDown();
}
{{WRAPPER_IMPLS}}

struct Case {
    std::string_view                  name;
    void (*fn)(void*);
    std::string_view                  file;
    unsigned                          line;
    std::span<const std::string_view> tags;
    std::span<const std::string_view> requirements;
    std::string_view                  skip_reason;
    bool                              should_skip;
    std::string_view                  fixture;        // empty for free tests
    bool                              fixture_stateful;
};

constexpr std::array<Case, {{CASE_COUNT}}> kCases = {
{{CASE_INITS}}
};
} // namespace

namespace {
bool wants_list(std::span<const char*> args) {
    for (const auto* arg : args) {
        if (arg != nullptr && std::string_view(arg) == "--list") {
            return true;
        }
    }
    return false;
}

bool wants_shuffle(std::span<const char*> args) {
    for (const auto* arg : args) {
        if (arg != nullptr && std::string_view(arg) == "--shuffle-fixtures") {
            return true;
        }
    }
    return false;
}

std::uint64_t parse_seed(std::span<const char*> args) {
    for (std::size_t i = 0; i + 1 < args.size(); ++i) {
        if (args[i] != nullptr && std::string_view(args[i]) == "--seed") {
            if (args[i + 1]) {
                std::uint64_t v = 0;
                for (const char ch : std::string_view(args[i + 1])) {
                    if (ch < '0' || ch > '9') { v = 0; break; }
                    v = v * 10 + static_cast<std::uint64_t>(ch - '0');
                }
                if (v != 0) return v;
            }
        }
    }
    return 0;
}
} // namespace

namespace {
struct Counters { std::size_t executed = 0; int failures = 0; };

void execute_one(const Case& test, void* ctx, Counters& c) {
    if (test.should_skip) {
        if (!test.skip_reason.empty()) {
            fmt::print("[ SKIP ] {} :: {}\n", test.name, test.skip_reason);
        } else {
            fmt::print("[ SKIP ] {}\n", test.name);
        }
        return;
    }
    ++c.executed;
    try {
        test.fn(ctx);
        fmt::print("[ PASS ] {}\n", test.name);
    } catch (const gentest::failure& err) {
        ++c.failures;
        fmt::print(stderr, "[ FAIL ] {} :: {}\n", test.name, err.what());
    } catch (const std::exception& err) {
        ++c.failures;
        fmt::print(stderr, "[ FAIL ] {} :: unexpected std::exception: {}\n", test.name, err.what());
    } catch (...) {
        ++c.failures;
        fmt::print(stderr, "[ FAIL ] {} :: unknown exception\n", test.name);
    }
}
} // namespace

// Group runners for fixture-based tests.
// Generated per-fixture group; invoked after free tests.
{{GROUP_RUNNERS}}

auto {{ENTRY_FUNCTION}}(std::span<const char*> args) -> int {
    if (wants_list(args)) {
        for (const auto& test : kCases) {
            std::string sections;
            if (!test.tags.empty() || !test.requirements.empty() || test.should_skip) {
                sections.push_back(' ');
                sections.push_back('[');
                bool first = true;
                if (!test.tags.empty()) {
                    sections.append("tags=");
                    for (std::size_t i = 0; i < test.tags.size(); ++i) {
                        if (i != 0) sections.push_back(',');
                        sections.append(test.tags[i]);
                    }
                    first = false;
                }
                if (!test.requirements.empty()) {
                    if (!first) sections.push_back(';');
                    sections.append("requires=");
                    for (std::size_t i = 0; i < test.requirements.size(); ++i) {
                        if (i != 0) sections.push_back(',');
                        sections.append(test.requirements[i]);
                    }
                    first = false;
                }
                if (test.should_skip) {
                    if (!first) sections.push_back(';');
                    sections.append("skip");
                    if (!test.skip_reason.empty()) { sections.push_back('='); sections.append(test.skip_reason); }
                }
                sections.push_back(']');
            }
            fmt::print("{}{} ({}:{})\n", test.name, sections, test.file, test.line);
        }
        return 0;
    }
    Counters counters;

    // Run free tests first (no fixture)
    for (const auto& test : kCases) {
        if (!test.fixture.empty()) continue; // fixtures handled in groups
        execute_one(test, nullptr, counters);
    }

    // Run fixture groups next
    const bool         shuffle = wants_shuffle(args);
    const std::uint64_t seed    = parse_seed(args);

    {{RUN_GROUPS}}

    if (counters.failures == 0) {
        fmt::print("Executed {} test(s).\n", counters.executed);
    } else {
        fmt::print(stderr, "Executed {} test(s) with {} failure(s).\n", counters.executed, counters.failures);
    }
    return counters.failures == 0 ? 0 : 1;
}

auto {{ENTRY_FUNCTION}}(int argc, char** argv) -> int {
    std::vector<const char*> args;
    args.reserve(static_cast<std::size_t>(argc));
    for (int i = 0; i < argc; ++i) {
        args.push_back(argv[i]);
    }
    return {{ENTRY_FUNCTION}}(std::span<const char*>{args.data(), args.size()});
}
