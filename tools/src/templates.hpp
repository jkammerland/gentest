// Embedded templates for code generation.
//
// These string constants define the entire output structure of the generated
// test implementation and its building blocks. They are consumed by the
// emitter (emit.cpp) and rendered via fmt::format (partials) or plain
// placeholder replacement (main). Keeping templates in one header makes them
// easy to locate, review, and change.
//
// Placeholders and where they apply:
// - Main file (test_impl):
//     {{INCLUDE_SOURCES}}, {{FORWARD_DECLS}}, {{TRAIT_DECLS}},
//     {{WRAPPER_IMPLS}}, {{CASE_INITS}}, {{GROUP_RUNNERS}},
//     {{RUN_GROUPS}}, {{ENTRY_FUNCTION}}
//   The emitter uses simple string replacement for these.
// - Partials (formatted with fmt::format):
//   wrapper_free:     {w}, {fn}
//   wrapper_free_fixtures: {w}, {fn}, {decls}, {setup}, {teardown}, {call}
//   wrapper_ephemeral:{w}, {fixture}, {method}
//   wrapper_stateful: {w}, {fixture}, {method}
//   case_entry:       {name}, {wrapper}, {file}, {line}, {tags}, {reqs},
//                     {skip_reason}, {should_skip}, {fixture}, {stateful}
//   group_runner_*:   {gid}, {fixture}, {count}, {idxs}
//   array_decl_*:     {name}; or {count}, {name}, {body}
//   forward_decl_*:   {name}; or {scope}, {lines}
//
// IMPORTANT: Partials are fed into fmt::format, so any literal braces that
// must appear in the generated C++ need to be doubled here (e.g. function
// bodies, initializer lists, random_device{{}}).

#pragma once

#include <string_view>

namespace gentest::codegen::tpl {

inline constexpr std::string_view test_impl = R"CPP(// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#include <array>
#include <exception>
#include <string>
#include <fmt/core.h>
#include <random>
#include <algorithm>
#include <type_traits>
#include <span>
#include <string_view>
#include <vector>

#include "gentest/runner.h"
#include "gentest/fixture.h"

// Include test sources so fixture types are visible for wrappers
{{INCLUDE_SOURCES}}

{{FORWARD_DECLS}}
namespace {

{{TRAIT_DECLS}}

// Per-case invocation wrappers. All wrappers use a uniform signature
//   void(void* ctx)
// Free tests ignore ctx; ephemeral fixtures construct a new instance per call;
// stateful fixtures expect ctx to point to the shared fixture instance.
template <typename T>
inline void gentest_maybe_setup(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureSetup, T>) t.setUp();
}

template <typename T>
inline void gentest_maybe_teardown(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureTearDown, T>) t.tearDown();
}
{{WRAPPER_IMPLS}}

struct Case {
    std::string_view                  name;
    void (*fn)(void*);
    std::string_view                  file;
    unsigned                          line;
    std::span<const std::string_view> tags;
    std::span<const std::string_view> requirements;
    std::string_view                  skip_reason;
    bool                              should_skip;
    std::string_view                  fixture;        // empty for free tests
    bool                              fixture_stateful;
};

constexpr std::array<Case, {{CASE_COUNT}}> kCases = {
{{CASE_INITS}}
};
} // namespace

namespace {
bool wants_list(std::span<const char*> args) {
    for (const auto* arg : args) {
        if (arg != nullptr && std::string_view(arg) == "--list") {
            return true;
        }
    }
    return false;
}

bool wants_shuffle(std::span<const char*> args) {
    for (const auto* arg : args) {
        if (arg != nullptr && std::string_view(arg) == "--shuffle-fixtures") {
            return true;
        }
    }
    return false;
}

std::uint64_t parse_seed(std::span<const char*> args) {
    for (std::size_t i = 0; i + 1 < args.size(); ++i) {
        if (args[i] != nullptr && std::string_view(args[i]) == "--seed") {
            if (args[i + 1]) {
                std::uint64_t v = 0;
                for (const char ch : std::string_view(args[i + 1])) {
                    if (ch < '0' || ch > '9') { v = 0; break; }
                    v = v * 10 + static_cast<std::uint64_t>(ch - '0');
                }
                if (v != 0) return v;
            }
        }
    }
    return 0;
}
} // namespace

namespace {
bool wants_help(std::span<const char*> args) {
    for (const auto* arg : args) if (arg && std::string_view(arg) == "--help") return true;
    return false;
}

bool wants_list_tests(std::span<const char*> args) {
    for (const auto* arg : args) if (arg && std::string_view(arg) == "--list-tests") return true;
    return false;
}

const char* get_arg_value(std::span<const char*> args, std::string_view prefix) {
    for (const auto* arg : args) {
        if (!arg) continue;
        std::string_view s(arg);
        if (s.rfind(prefix, 0) == 0) return arg + prefix.size();
    }
    return nullptr;
}

bool wildcard_match(std::string_view text, std::string_view pattern) {
    std::size_t ti = 0, pi = 0, star = std::string_view::npos, mark = 0;
    while (ti < text.size()) {
        if (pi < pattern.size() && (pattern[pi] == '?' || pattern[pi] == text[ti])) { ++ti; ++pi; continue; }
        if (pi < pattern.size() && pattern[pi] == '*') { star = pi++; mark = ti; continue; }
        if (star != std::string_view::npos) { pi = star + 1; ti = ++mark; continue; }
        return false;
    }
    while (pi < pattern.size() && pattern[pi] == '*') ++pi;
    return pi == pattern.size();
}

std::string join_span(std::span<const std::string_view> items, char sep) {
    std::string out;
    for (std::size_t i = 0; i < items.size(); ++i) {
        if (i != 0) out.push_back(sep);
        out.append(items[i]);
    }
    return out;
}
} // namespace

namespace {
struct Counters { std::size_t executed = 0; int failures = 0; };

void execute_one(const Case& test, void* ctx, Counters& c) {
    if (test.should_skip) {
        if (!test.skip_reason.empty()) {
            fmt::print("[ SKIP ] {} :: {}\n", test.name, test.skip_reason);
        } else {
            fmt::print("[ SKIP ] {}\n", test.name);
        }
        return;
    }
    ++c.executed;
    try {
        test.fn(ctx);
        fmt::print("[ PASS ] {}\n", test.name);
    } catch (const gentest::failure& err) {
        ++c.failures;
        fmt::print(stderr, "[ FAIL ] {} :: {}\n", test.name, err.what());
    } catch (const std::exception& err) {
        ++c.failures;
        fmt::print(stderr, "[ FAIL ] {} :: unexpected std::exception: {}\n", test.name, err.what());
    } catch (...) {
        ++c.failures;
        fmt::print(stderr, "[ FAIL ] {} :: unknown exception\n", test.name);
    }
}
} // namespace

// Group runners for fixture-based tests.
// Generated per-fixture group; invoked after free tests.
{{GROUP_RUNNERS}}

auto {{ENTRY_FUNCTION}}(std::span<const char*> args) -> int {
    if (wants_help(args)) {
        fmt::print("gentest v{{VERSION}}\n");
        fmt::print("Usage: [options]\n");
        fmt::print("  --help                Show this help\n");
        fmt::print("  --list-tests          List test names (one per line)\n");
        fmt::print("  --list                List tests with metadata\n");
        fmt::print("  --run-test=<name>     Run a single test by exact name\n");
        fmt::print("  --filter=<pattern>    Run tests matching wildcard pattern (*, ?)\n");
        fmt::print("  --shuffle-fixtures    Shuffle order within each fixture group\n");
        fmt::print("  --seed N              RNG seed used with --shuffle-fixtures\n");
        return 0;
    }
    if (wants_list_tests(args)) {
        for (const auto& t : kCases) fmt::print("{}\n", t.name);
        return 0;
    }
    if (wants_list(args)) {
        for (const auto& test : kCases) {
            std::string sections;
            if (!test.tags.empty() || !test.requirements.empty() || test.should_skip) {
                sections.push_back(' ');
                sections.push_back('[');
                bool first = true;
                if (!test.tags.empty()) {
                    sections.append("tags=");
                    sections.append(join_span(test.tags, ','));
                    first = false;
                }
                if (!test.requirements.empty()) {
                    if (!first) sections.push_back(';');
                    sections.append("requires=");
                    sections.append(join_span(test.requirements, ','));
                    first = false;
                }
                if (test.should_skip) {
                    if (!first) sections.push_back(';');
                    sections.append("skip");
                    if (!test.skip_reason.empty()) { sections.push_back('='); sections.append(test.skip_reason); }
                }
                sections.push_back(']');
            }
            fmt::print("{}{} ({}:{})\n", test.name, sections, test.file, test.line);
        }
        return 0;
    }
    Counters counters;

    // Selection support: --run-test / --filter
    const char* run_exact = get_arg_value(args, "--run-test=");
    const char* filter_pat = get_arg_value(args, "--filter=");
    if (run_exact || filter_pat) {
        std::vector<std::size_t> sel;
        if (run_exact) {
            for (std::size_t i = 0; i < kCases.size(); ++i) if (kCases[i].name == run_exact) { sel.push_back(i); break; }
            if (sel.empty()) { fmt::print(stderr, "Test not found: {}\n", run_exact); return 1; }
        } else {
            for (std::size_t i = 0; i < kCases.size(); ++i) if (wildcard_match(kCases[i].name, filter_pat)) sel.push_back(i);
            if (sel.empty()) { fmt::print("Executed 0 test(s).\n"); return 0; }
        }
        // Free tests
        for (auto i : sel) { const auto& t = kCases[i]; if (!t.fixture.empty()) continue; execute_one(t, nullptr, counters); }
        // Fixture tests: for now run selected ones as ephemeral in selection mode to avoid UB on unknown fixture types.
        const bool         shuffle = wants_shuffle(args);
        const std::uint64_t seed    = parse_seed(args);
        // Group by fixture name
        std::vector<std::pair<std::string_view, std::vector<std::size_t>>> groups;
        for (auto i : sel) { const auto& t = kCases[i]; if (t.fixture.empty()) continue; auto it = std::find_if(groups.begin(), groups.end(), [&](auto& g){return g.first==t.fixture;}); if (it==groups.end()) groups.push_back({t.fixture,{i}}); else it->second.push_back(i); }
        for (std::size_t gid = 0; gid < groups.size(); ++gid) {
            auto order = groups[gid].second;
            if (shuffle && order.size() > 1) { std::mt19937_64 rng(seed ? (seed + gid) : std::mt19937_64::result_type(std::random_device{}())); std::shuffle(order.begin(), order.end(), rng); }
            for (auto i : order) execute_one(kCases[i], nullptr, counters);
        }
        if (counters.failures == 0) fmt::print("Executed {} test(s).\n", counters.executed);
        else fmt::print(stderr, "Executed {} test(s) with {} failure(s).\n", counters.executed, counters.failures);
        return counters.failures == 0 ? 0 : 1;
    }

    // Default path: run all tests with built-in grouping
    for (const auto& t : kCases) { if (!t.fixture.empty()) continue; execute_one(t, nullptr, counters); }
    const bool         shuffle = wants_shuffle(args);
    const std::uint64_t seed    = parse_seed(args);
    {{RUN_GROUPS}}
    if (counters.failures == 0) fmt::print("Executed {} test(s).\n", counters.executed);
    else fmt::print(stderr, "Executed {} test(s) with {} failure(s).\n", counters.executed, counters.failures);
    return counters.failures == 0 ? 0 : 1;
}

auto {{ENTRY_FUNCTION}}(int argc, char** argv) -> int {
    std::vector<const char*> args;
    args.reserve(static_cast<std::size_t>(argc));
    for (int i = 0; i < argc; ++i) {
        args.push_back(argv[i]);
    }
    return {{ENTRY_FUNCTION}}(std::span<const char*>{args.data(), args.size()});
}
)CPP";

inline constexpr std::string_view wrapper_free = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    {fn}{args};
}}

)FMT";

inline constexpr std::string_view wrapper_free_fixtures = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
{decls}{setup}    {fn}{call};
{teardown}}}

)FMT";

inline constexpr std::string_view wrapper_ephemeral = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    {fixture} fx_;
    gentest_maybe_setup(fx_);
    fx_.{method}{args};
    gentest_maybe_teardown(fx_);
}}

)FMT";

inline constexpr std::string_view wrapper_stateful = R"FMT(static void {w}(void* ctx_) {{
    auto* fx_ = static_cast<{fixture}*>(ctx_);
    gentest_maybe_setup(*fx_);
    fx_->{method}{args};
    gentest_maybe_teardown(*fx_);
}}

)FMT";

inline constexpr std::string_view case_entry = R"FMT(    Case{{
        "{name}",
        &{wrapper},
        "{file}",
        {line},
        std::span{{{tags}}},
        std::span{{{reqs}}},
        {skip_reason},
        {should_skip},
        {fixture},
        {stateful}
    }},

)FMT";

inline constexpr std::string_view group_runner_stateless = R"FMT(static void gentest_run_group_{gid}(bool shuffle_, std::uint64_t seed_, Counters& counters_) {{
    using Fixture = {fixture};
    const std::array<std::size_t, {count}> idxs_ = {{ {idxs} }};
    std::vector<std::size_t> order_(idxs_.begin(), idxs_.end());
    if (shuffle_ && order_.size() > 1) {{ std::mt19937_64 rng_(seed_ ? (seed_ + {gid}) : std::mt19937_64::result_type(std::random_device{{}}())); std::shuffle(order_.begin(), order_.end(), rng_); }}
    for (auto i_ : order_) {{ execute_one(kCases[i_], nullptr, counters_); }}
}}

)FMT";

inline constexpr std::string_view group_runner_stateful = R"FMT(static void gentest_run_group_{gid}(bool shuffle_, std::uint64_t seed_, Counters& counters_) {{
    using Fixture = {fixture};
    const std::array<std::size_t, {count}> idxs_ = {{ {idxs} }};
    std::vector<std::size_t> order_(idxs_.begin(), idxs_.end());
    if (shuffle_ && order_.size() > 1) {{ std::mt19937_64 rng_(seed_ ? (seed_ + {gid}) : std::mt19937_64::result_type(std::random_device{{}}())); std::shuffle(order_.begin(), order_.end(), rng_); }}
    Fixture fx_;
    for (auto i_ : order_) {{ execute_one(kCases[i_], &fx_, counters_); }}
}}

)FMT";

inline constexpr std::string_view array_decl_empty = R"FMT(constexpr std::array<std::string_view, 0> {name}{{}};

)FMT";

inline constexpr std::string_view array_decl_nonempty = R"FMT(constexpr std::array<std::string_view, {count}> {name} = {{
{body}
}};

)FMT";

inline constexpr std::string_view forward_decl_line = R"FMT(void {name}();

)FMT";

inline constexpr std::string_view forward_decl_ns = R"FMT(namespace {scope} {{
{lines}}} // namespace {scope}

)FMT";

} // namespace gentest::codegen::tpl
