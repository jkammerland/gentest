// Embedded templates for code generation.
//
// These string constants define the entire output structure of the generated
// test implementation and its building blocks. They are consumed by the
// emitter (emit.cpp) and rendered via fmt::format (partials) or plain
// placeholder replacement (main). Keeping templates in one header makes them
// easy to locate, review, and change.
//
// Placeholders and where they apply:
// - Main file (test_impl):
//     {{INCLUDE_SOURCES}}, {{FORWARD_DECLS}}, {{TRAIT_DECLS}},
//     {{WRAPPER_IMPLS}}, {{CASE_INITS}}, {{GROUP_RUNNERS}},
//     {{RUN_GROUPS}}, {{ENTRY_FUNCTION}}, {{FIXTURE_REGISTRATIONS}}
//   The emitter uses simple string replacement for these.
// - Partials (formatted with fmt::format):
//   wrapper_free:     {w}, {fn}
//   wrapper_free_fixtures: {w}, {fn}, {decls}, {setup_flags}, {setup}, {teardown}, {call},
//                          {bench_decls}, {bench_inits}, {bench_setup}, {bench_teardown}, {bench_invoke}
//   wrapper_ephemeral:{w}, {fixture}, {method}, {bench_invoke}
//   wrapper_stateful: {w}, {fixture}, {method}
//   case_entry:       {name}, {wrapper}, {file}, {line}, {tags}, {reqs},
//                     {skip_reason}, {should_skip}, {fixture}, {lifetime}, {suite}
//   group_runner_*:   {gid}, {fixture}, {count}, {idxs}
//   array_decl_*:     {name}; or {count}, {name}, {body}
//   forward_decl_*:   {name}; or {scope}, {lines}
//
// IMPORTANT: Partials are fed into fmt::format, so any literal braces that
// must appear in the generated C++ need to be doubled here (e.g. function
// bodies, initializer lists, random_device{{}}).

#pragma once

#include <string_view>

namespace gentest::codegen::tpl {

inline constexpr std::string_view test_impl = R"CPP(// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#include <array>
#include <span>
#include <type_traits>

#include "gentest/runner.h"
#include "gentest/fixture.h"

// Include test sources so fixture types are visible for wrappers
{{INCLUDE_SOURCES}}

{{FORWARD_DECLS}}

namespace {

{{TRAIT_DECLS}}

// Per-case invocation wrappers. All wrappers use a uniform signature
//   void(void* ctx)
// Free tests ignore ctx; ephemeral fixtures construct a new instance per call;
// shared fixtures expect ctx to point to the shared fixture instance.
template <typename T>
inline void gentest_maybe_setup(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureSetup, T>) t.setUp();
}

template <typename T>
inline void gentest_maybe_teardown(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureTearDown, T>) t.tearDown();
}

inline void gentest_record_fixture_failure(std::string_view fixture, std::string_view reason) {
    std::string msg;
    msg.reserve(fixture.size() + reason.size() + 40);
    msg.append("fixture allocation failed for '");
    msg.append(fixture);
    msg.push_back('\'');
    if (!reason.empty()) {
        msg.append(": ");
        msg.append(reason);
    }
    if (::gentest::detail::bench_phase() != ::gentest::detail::BenchPhase::None) {
        ::gentest::detail::record_bench_error(std::move(msg));
        return;
    }
    gentest::detail::record_failure(std::move(msg));
}

inline void gentest_record_shared_fixture_unavailable(std::string_view fixture, std::string_view reason) {
    std::string msg;
    msg.reserve(fixture.size() + reason.size() + 48);
    msg.append("shared fixture unavailable for '");
    msg.append(fixture);
    msg.push_back('\'');
    if (!reason.empty()) {
        msg.append(": ");
        msg.append(reason);
    }
#if GENTEST_EXCEPTIONS_ENABLED
    ::gentest::detail::skip_shared_fixture_unavailable(msg);
#else
    if (::gentest::detail::bench_phase() != ::gentest::detail::BenchPhase::None) {
        ::gentest::detail::record_bench_error(std::move(msg));
        return;
    }
    ::gentest::detail::record_failure(std::move(msg));
#endif
}

template <typename TeardownFn>
struct gentest_noexceptions_local_teardown {
    TeardownFn *teardown = nullptr;
    bool        ran      = false;

    static void run(void *user_data) noexcept {
        auto *state = static_cast<gentest_noexceptions_local_teardown *>(user_data);
        if (!state || state->ran || !state->teardown) return;
        state->ran = true;
        (*state->teardown)();
    }

    void run_now() noexcept { run(this); }
};

template <typename BodyFn, typename TeardownFn>
inline void gentest_run_with_local_teardown(BodyFn &&body, TeardownFn &&teardown) {
#if GENTEST_EXCEPTIONS_ENABLED
    try {
        body();
    } catch (...) {
        try {
            teardown();
        } catch (...) {
        }
        throw;
    }
    teardown();
#else
    auto teardown_fn = std::forward<TeardownFn>(teardown);
    gentest_noexceptions_local_teardown<decltype(teardown_fn)> teardown_state{&teardown_fn};
    ::gentest::detail::NoExceptionsFatalHookScope            fatal_scope(&decltype(teardown_state)::run, &teardown_state);
    body();
    teardown_state.run_now();
#endif
}

template <typename Handle>
inline bool gentest_init_fixture(Handle& handle, std::string_view fixture) {
    if (!handle.init()) {
        gentest_record_fixture_failure(fixture, "returned null");
        return false;
    }
    return true;
}

template <typename T>
inline bool gentest_init_shared_fixture(::gentest::detail::FixtureHandle<T>& handle,
                                        ::gentest::detail::SharedFixtureScope scope,
                                        std::string_view suite,
                                        std::string_view fixture) {
    std::string reason;
    auto shared = ::gentest::detail::get_shared_fixture_typed<T>(scope, suite, fixture, reason);
    if (!shared) {
        gentest_record_shared_fixture_unavailable(fixture, reason);
        return false;
    }
    if (!handle.init_shared(std::move(shared))) {
        gentest_record_fixture_failure(fixture, "returned null");
        return false;
    }
    return true;
}
{{WRAPPER_IMPLS}}

constexpr std::array<gentest::Case, {{CASE_COUNT}}> kCases = {
{{CASE_INITS}}
};

struct GentestRegistrar {
    GentestRegistrar() {
{{FIXTURE_REGISTRATIONS}}        gentest::detail::register_cases(std::span{kCases});
    }
};

[[maybe_unused]] const GentestRegistrar kGentestRegistrar{};
} // namespace
)CPP";;

inline constexpr std::string_view tu_header = R"CPP(// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#pragma once

namespace gentest::generated {
void {{REGISTER_FN}}();
} // namespace gentest::generated
)CPP";;

inline constexpr std::string_view tu_registration_header = R"CPP(// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#pragma once

#include <array>
#include <span>
#include <type_traits>

#include "gentest/runner.h"
#include "gentest/fixture.h"

{{FORWARD_DECLS}}

namespace {

{{TRAIT_DECLS}}

// Per-case invocation wrappers. All wrappers use a uniform signature
//   void(void* ctx)
// Free tests ignore ctx; ephemeral fixtures construct a new instance per call;
// shared fixtures expect ctx to point to the shared fixture instance.
template <typename T>
inline void gentest_maybe_setup(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureSetup, T>) t.setUp();
}

template <typename T>
inline void gentest_maybe_teardown(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureTearDown, T>) t.tearDown();
}

inline void gentest_record_fixture_failure(std::string_view fixture, std::string_view reason) {
    std::string msg;
    msg.reserve(fixture.size() + reason.size() + 40);
    msg.append("fixture allocation failed for '");
    msg.append(fixture);
    msg.push_back('\'');
    if (!reason.empty()) {
        msg.append(": ");
        msg.append(reason);
    }
    if (::gentest::detail::bench_phase() != ::gentest::detail::BenchPhase::None) {
        ::gentest::detail::record_bench_error(std::move(msg));
        return;
    }
    gentest::detail::record_failure(std::move(msg));
}

inline void gentest_record_shared_fixture_unavailable(std::string_view fixture, std::string_view reason) {
    std::string msg;
    msg.reserve(fixture.size() + reason.size() + 48);
    msg.append("shared fixture unavailable for '");
    msg.append(fixture);
    msg.push_back('\'');
    if (!reason.empty()) {
        msg.append(": ");
        msg.append(reason);
    }
#if GENTEST_EXCEPTIONS_ENABLED
    ::gentest::detail::skip_shared_fixture_unavailable(msg);
#else
    if (::gentest::detail::bench_phase() != ::gentest::detail::BenchPhase::None) {
        ::gentest::detail::record_bench_error(std::move(msg));
        return;
    }
    ::gentest::detail::record_failure(std::move(msg));
#endif
}

template <typename TeardownFn>
struct gentest_noexceptions_local_teardown {
    TeardownFn *teardown = nullptr;
    bool        ran      = false;

    static void run(void *user_data) noexcept {
        auto *state = static_cast<gentest_noexceptions_local_teardown *>(user_data);
        if (!state || state->ran || !state->teardown) return;
        state->ran = true;
        (*state->teardown)();
    }

    void run_now() noexcept { run(this); }
};

template <typename BodyFn, typename TeardownFn>
inline void gentest_run_with_local_teardown(BodyFn &&body, TeardownFn &&teardown) {
#if GENTEST_EXCEPTIONS_ENABLED
    try {
        body();
    } catch (...) {
        try {
            teardown();
        } catch (...) {
        }
        throw;
    }
    teardown();
#else
    auto teardown_fn = std::forward<TeardownFn>(teardown);
    gentest_noexceptions_local_teardown<decltype(teardown_fn)> teardown_state{&teardown_fn};
    ::gentest::detail::NoExceptionsFatalHookScope            fatal_scope(&decltype(teardown_state)::run, &teardown_state);
    body();
    teardown_state.run_now();
#endif
}

template <typename Handle>
inline bool gentest_init_fixture(Handle& handle, std::string_view fixture) {
    if (!handle.init()) {
        gentest_record_fixture_failure(fixture, "returned null");
        return false;
    }
    return true;
}

template <typename T>
inline bool gentest_init_shared_fixture(::gentest::detail::FixtureHandle<T>& handle,
                                        ::gentest::detail::SharedFixtureScope scope,
                                        std::string_view suite,
                                        std::string_view fixture) {
    std::string reason;
    auto shared = ::gentest::detail::get_shared_fixture_typed<T>(scope, suite, fixture, reason);
    if (!shared) {
        gentest_record_shared_fixture_unavailable(fixture, reason);
        return false;
    }
    if (!handle.init_shared(std::move(shared))) {
        gentest_record_fixture_failure(fixture, "returned null");
        return false;
    }
    return true;
}
{{WRAPPER_IMPLS}}

constexpr std::array<gentest::Case, {{CASE_COUNT}}> kCases = {
{{CASE_INITS}}
};
} // namespace

namespace gentest::generated {
inline void {{REGISTER_FN}}() { gentest::detail::register_cases(std::span{kCases}); }
} // namespace gentest::generated

namespace {
struct GentestRegistrar {
    GentestRegistrar() {
{{FIXTURE_REGISTRATIONS}}        gentest::generated::{{REGISTER_FN}}();
    }
};
[[maybe_unused]] const GentestRegistrar kGentestRegistrar{};
} // namespace
)CPP";;

inline constexpr std::string_view wrapper_free = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    const auto phase = ::gentest::detail::bench_phase();
    if (phase != ::gentest::detail::BenchPhase::None) {{
        if (phase == ::gentest::detail::BenchPhase::Call) {{
            {invoke}
        }}
        return;
    }}
    {invoke}
}}

)FMT";

inline constexpr std::string_view wrapper_free_fixtures = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    const auto phase = ::gentest::detail::bench_phase();
    if (phase != ::gentest::detail::BenchPhase::None) {{
        struct BenchState {{
{bench_decls}        bool ready = false;
        }};
        static thread_local BenchState bench_state{{}};
        if (phase == ::gentest::detail::BenchPhase::Setup) {{
            bench_state = BenchState{{}};
{bench_inits}{bench_setup}            bench_state.ready = true;
            return;
        }}
        if (phase == ::gentest::detail::BenchPhase::Teardown) {{
            if (bench_state.ready) {{
{bench_teardown}            }}
            bench_state = BenchState{{}};
            return;
        }}
        if (phase == ::gentest::detail::BenchPhase::Call) {{
            if (!bench_state.ready) return;
            {bench_invoke}
            return;
        }}
        return;
    }}
{decls}{inits}{setup_flags}    gentest_run_with_local_teardown(
        [&] {{
{setup}            {invoke}
        }},
        [&] {{
{teardown}        }});
}}

)FMT";

inline constexpr std::string_view wrapper_ephemeral = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    const auto phase = ::gentest::detail::bench_phase();
    if (phase != ::gentest::detail::BenchPhase::None) {{
        struct BenchState {{
            ::gentest::detail::FixtureHandle<{fixture}> fx_{{::gentest::detail::FixtureHandle<{fixture}>::empty()}};
            bool ready = false;
        }};
        static thread_local BenchState bench_state{{}};
        if (phase == ::gentest::detail::BenchPhase::Setup) {{
            bench_state = BenchState{{}};
            if (!gentest_init_fixture(bench_state.fx_, "{fixture}")) return;
            gentest_maybe_setup(bench_state.fx_.ref());
            bench_state.ready = true;
            return;
        }}
        if (phase == ::gentest::detail::BenchPhase::Teardown) {{
            if (bench_state.ready) gentest_maybe_teardown(bench_state.fx_.ref());
            bench_state = BenchState{{}};
            return;
        }}
        if (phase == ::gentest::detail::BenchPhase::Call) {{
            if (!bench_state.ready) return;
            {bench_invoke}
            return;
        }}
        return;
    }}
    auto fx_ = ::gentest::detail::FixtureHandle<{fixture}>::empty();
    if (!gentest_init_fixture(fx_, "{fixture}")) return;
    bool fx_setup_complete = false;
    gentest_run_with_local_teardown(
        [&] {{
            gentest_maybe_setup(fx_.ref());
            fx_setup_complete = true;
            {invoke}
        }},
        [&] {{
            if (fx_setup_complete) gentest_maybe_teardown(fx_.ref());
        }});
}}

)FMT";

inline constexpr std::string_view wrapper_stateful = R"FMT(static void {w}(void* ctx_) {{
    auto* fx_ = static_cast<{fixture}*>(ctx_);
    if (!fx_) {{
        gentest_record_fixture_failure("{fixture}", "instance missing");
        return;
    }}
    const auto phase = ::gentest::detail::bench_phase();
    if (phase != ::gentest::detail::BenchPhase::None) {{
        if (phase == ::gentest::detail::BenchPhase::Setup) {{
            return;
        }}
        if (phase == ::gentest::detail::BenchPhase::Teardown) {{
            return;
        }}
        if (phase == ::gentest::detail::BenchPhase::Call) {{
            {invoke}
            return;
        }}
        return;
    }}
    {invoke}
}}

)FMT";

inline constexpr std::string_view case_entry = R"FMT(    gentest::Case{{
        .name = "{name}",
        .fn = &{wrapper},
        .file = "{file}",
        .line = {line},
        .is_benchmark = {is_bench},
        .is_jitter = {is_jitter},
        .is_baseline = {is_baseline},
        .tags = std::span{{{tags}}},
        .requirements = std::span{{{reqs}}},
        .skip_reason = {skip_reason},
        .should_skip = {should_skip},
        .fixture = {fixture},
        .fixture_lifetime = {lifetime},
        .suite = {suite}
    }},

)FMT";

inline constexpr std::string_view group_runner_ephemeral = R"FMT()FMT";
inline constexpr std::string_view group_runner_suite = R"FMT()FMT";
inline constexpr std::string_view group_runner_global = R"FMT()FMT";

inline constexpr std::string_view array_decl_empty = R"FMT(constexpr std::array<std::string_view, 0> {name}{{}};

)FMT";

inline constexpr std::string_view array_decl_nonempty = R"FMT(constexpr std::array<std::string_view, {count}> {name} = {{
{body}
}};

)FMT";

inline constexpr std::string_view forward_decl_line = R"FMT(void {name}();

)FMT";

inline constexpr std::string_view forward_decl_ns = R"FMT(namespace {scope} {{
{lines}}} // namespace {scope}

)FMT";

} // namespace gentest::codegen::tpl
