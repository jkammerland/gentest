// Embedded templates for code generation.
//
// These string constants define the entire output structure of the generated
// test implementation and its building blocks. They are consumed by the
// emitter (emit.cpp) and rendered via fmt::format (partials) or plain
// placeholder replacement (main). Keeping templates in one header makes them
// easy to locate, review, and change.
//
// Placeholders and where they apply:
// - Main file (test_impl):
//     {{INCLUDE_SOURCES}}, {{FORWARD_DECLS}}, {{TRAIT_DECLS}},
//     {{WRAPPER_IMPLS}}, {{CASE_INITS}}, {{GROUP_RUNNERS}},
//     {{RUN_GROUPS}}, {{ENTRY_FUNCTION}}
//   The emitter uses simple string replacement for these.
// - Partials (formatted with fmt::format):
//   wrapper_free:     {w}, {fn}
//   wrapper_free_fixtures: {w}, {fn}, {decls}, {setup}, {teardown}, {call}
//   wrapper_ephemeral:{w}, {fixture}, {method}
//   wrapper_stateful: {w}, {fixture}, {method}
//   case_entry:       {name}, {wrapper}, {file}, {line}, {tags}, {reqs},
//                     {skip_reason}, {should_skip}, {fixture}, {lifetime}, {suite}
//   group_runner_*:   {gid}, {fixture}, {count}, {idxs}
//   array_decl_*:     {name}; or {count}, {name}, {body}
//   forward_decl_*:   {name}; or {scope}, {lines}
//
// IMPORTANT: Partials are fed into fmt::format, so any literal braces that
// must appear in the generated C++ need to be doubled here (e.g. function
// bodies, initializer lists, random_device{{}}).

#pragma once

#include <string_view>

namespace gentest::codegen::tpl {

inline constexpr std::string_view test_impl = R"CPP(// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#include <array>
#include <string>
#include <span>
#include <type_traits>

#include "gentest/runner.h"
#include "gentest/fixture.h"

// Include test sources so fixture types are visible for wrappers
{{INCLUDE_SOURCES}}

// After sources, include mock API to bring in the generated mock registry
// and inline implementations once all original types are visible.
#include "gentest/mock.h"

{{FORWARD_DECLS}}
{{ACCESSOR_DECLS}}

namespace {

{{TRAIT_DECLS}}

// Per-case invocation wrappers. All wrappers use a uniform signature
//   void(void* ctx)
// Free tests ignore ctx; ephemeral fixtures construct a new instance per call;
// shared fixtures expect ctx to point to the shared fixture instance.
template <typename T>
inline void gentest_maybe_setup(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureSetup, T>) t.setUp();
}

template <typename T>
inline void gentest_maybe_teardown(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureTearDown, T>) t.tearDown();
}
{{WRAPPER_IMPLS}}

constexpr std::array<gentest::Case, {{CASE_COUNT}}> kCases = {
{{CASE_INITS}}
};
} // namespace

// Accessors and (unused) group runners for fixture-based tests.
{{GROUP_RUNNERS}}

namespace gentest {
const Case* get_cases() { return kCases.data(); }
std::size_t get_case_count() { return kCases.size(); }
} // namespace gentest
)CPP";;

inline constexpr std::string_view wrapper_free = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    {invoke}
}}

)FMT";

inline constexpr std::string_view wrapper_free_fixtures = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
{decls}{setup}    {invoke}
{teardown}}}

)FMT";

inline constexpr std::string_view wrapper_ephemeral = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    {fixture} fx_;
    gentest_maybe_setup(fx_);
    {invoke}
    gentest_maybe_teardown(fx_);
}}

)FMT";

inline constexpr std::string_view wrapper_stateful = R"FMT(static void {w}(void* ctx_) {{
    auto* fx_ = static_cast<{fixture}*>(ctx_);
    gentest_maybe_setup(*fx_);
    {invoke}
    gentest_maybe_teardown(*fx_);
}}

)FMT";

inline constexpr std::string_view case_entry = R"FMT(    gentest::Case{{
        .name = "{name}",
        .fn = &{wrapper},
        .file = "{file}",
        .line = {line},
        .tags = std::span{{{tags}}},
        .requirements = std::span{{{reqs}}},
        .skip_reason = {skip_reason},
        .should_skip = {should_skip},
        .fixture = {fixture},
        .fixture_lifetime = {lifetime},
        .suite = {suite},
        .acquire_fixture = {acquire}
    }},

)FMT";

inline constexpr std::string_view group_runner_ephemeral = R"FMT()FMT";

inline constexpr std::string_view group_runner_suite = R"FMT(static void* gentest_access_fixture_{gid}(std::string_view suite_) {{
    using Fixture = {fixture};
    struct Entry {{ std::string_view key; std::unique_ptr<Fixture> instance; }};
    static std::vector<Entry> fixtures_;
    for (auto& entry : fixtures_) {{ if (entry.key == suite_) return entry.instance.get(); }}
    fixtures_.push_back(Entry{{ .key = suite_, .instance = std::make_unique<Fixture>() }});
    return fixtures_.back().instance.get();
}}

)FMT";

inline constexpr std::string_view group_runner_global = R"FMT(static void* gentest_access_fixture_{gid}(std::string_view) {{
    using Fixture = {fixture};
    static Fixture fx_;
    return &fx_;
}}

)FMT";

inline constexpr std::string_view array_decl_empty = R"FMT(constexpr std::array<std::string_view, 0> {name}{{}};

)FMT";

inline constexpr std::string_view array_decl_nonempty = R"FMT(constexpr std::array<std::string_view, {count}> {name} = {{
{body}
}};

)FMT";

inline constexpr std::string_view forward_decl_line = R"FMT(void {name}();

)FMT";

inline constexpr std::string_view forward_decl_ns = R"FMT(namespace {scope} {{
{lines}}} // namespace {scope}

)FMT";

} // namespace gentest::codegen::tpl
