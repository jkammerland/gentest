// Embedded templates for code generation.
//
// These string constants define the entire output structure of the generated
// test implementation and its building blocks. They are consumed by the
// emitter (emit.cpp) and rendered via fmt::format (partials) or plain
// placeholder replacement (main). Keeping templates in one header makes them
// easy to locate, review, and change.
//
// Placeholders and where they apply:
// - Main file (test_impl):
//     {{INCLUDE_SOURCES}}, {{FORWARD_DECLS}}, {{TRAIT_DECLS}},
//     {{WRAPPER_IMPLS}}, {{CASE_INITS}}, {{GROUP_RUNNERS}},
//     {{RUN_GROUPS}}, {{ENTRY_FUNCTION}}
//   The emitter uses simple string replacement for these.
// - Partials (formatted with fmt::format):
//   wrapper_free:     {w}, {fn}
//   wrapper_free_fixtures: {w}, {fn}, {decls}, {setup}, {teardown}, {call}
//   wrapper_ephemeral:{w}, {fixture}, {method}
//   wrapper_stateful: {w}, {fixture}, {method}
//   case_entry:       {name}, {wrapper}, {file}, {line}, {tags}, {reqs},
//                     {skip_reason}, {should_skip}, {fixture}, {lifetime}, {suite}
//   group_runner_*:   {gid}, {fixture}, {count}, {idxs}
//   array_decl_*:     {name}; or {count}, {name}, {body}
//   forward_decl_*:   {name}; or {scope}, {lines}
//
// IMPORTANT: Partials are fed into fmt::format, so any literal braces that
// must appear in the generated C++ need to be doubled here (e.g. function
// bodies, initializer lists, random_device{{}}).

#pragma once

#include <string_view>

namespace gentest::codegen::tpl {

inline constexpr std::string_view test_impl = R"CPP(// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#include <array>
#include <span>
#include <type_traits>

#include "gentest/runner.h"
#include "gentest/fixture.h"

// Include test sources so fixture types are visible for wrappers
{{INCLUDE_SOURCES}}

{{FORWARD_DECLS}}

namespace {

{{TRAIT_DECLS}}

// Per-case invocation wrappers. All wrappers use a uniform signature
//   void(void* ctx)
// Free tests ignore ctx; ephemeral fixtures construct a new instance per call;
// shared fixtures expect ctx to point to the shared fixture instance.
template <typename T>
inline void gentest_maybe_setup(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureSetup, T>) t.setUp();
}

template <typename T>
inline void gentest_maybe_teardown(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureTearDown, T>) t.tearDown();
}
{{WRAPPER_IMPLS}}

constexpr std::array<gentest::Case, {{CASE_COUNT}}> kCases = {
{{CASE_INITS}}
};

struct GentestRegistrar {
    GentestRegistrar() { gentest::detail::register_cases(std::span{kCases}); }
};

[[maybe_unused]] const GentestRegistrar kGentestRegistrar{};
} // namespace
)CPP";;

inline constexpr std::string_view tu_header = R"CPP(// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#pragma once

namespace gentest::generated {
void {{REGISTER_FN}}();
} // namespace gentest::generated
)CPP";;

inline constexpr std::string_view tu_registration_header = R"CPP(// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#pragma once

#include <array>
#include <span>
#include <type_traits>

#include "gentest/runner.h"
#include "gentest/fixture.h"

{{FORWARD_DECLS}}

namespace {

{{TRAIT_DECLS}}

// Per-case invocation wrappers. All wrappers use a uniform signature
//   void(void* ctx)
// Free tests ignore ctx; ephemeral fixtures construct a new instance per call;
// shared fixtures expect ctx to point to the shared fixture instance.
template <typename T>
inline void gentest_maybe_setup(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureSetup, T>) t.setUp();
}

template <typename T>
inline void gentest_maybe_teardown(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureTearDown, T>) t.tearDown();
}
{{WRAPPER_IMPLS}}

constexpr std::array<gentest::Case, {{CASE_COUNT}}> kCases = {
{{CASE_INITS}}
};
} // namespace

namespace gentest::generated {
inline void {{REGISTER_FN}}() { gentest::detail::register_cases(std::span{kCases}); }
} // namespace gentest::generated

namespace {
struct GentestRegistrar {
    GentestRegistrar() { gentest::generated::{{REGISTER_FN}}(); }
};
[[maybe_unused]] const GentestRegistrar kGentestRegistrar{};
} // namespace
)CPP";;

inline constexpr std::string_view wrapper_free = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    {invoke}
}}

)FMT";

inline constexpr std::string_view wrapper_free_fixtures = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
{decls}{setup}    {invoke}
{teardown}}}

)FMT";

inline constexpr std::string_view wrapper_ephemeral = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    ::gentest::detail::FixtureHandle<{fixture}> fx_;
    gentest_maybe_setup(fx_.ref());
    {invoke}
    gentest_maybe_teardown(fx_.ref());
}}

)FMT";

inline constexpr std::string_view wrapper_stateful = R"FMT(static void {w}(void* ctx_) {{
    auto* fx_ = static_cast<{fixture}*>(ctx_);
    gentest_maybe_setup(*fx_);
    {invoke}
    gentest_maybe_teardown(*fx_);
}}

)FMT";

inline constexpr std::string_view case_entry = R"FMT(    gentest::Case{{
        .name = "{name}",
        .fn = &{wrapper},
        .file = "{file}",
        .line = {line},
        .is_benchmark = {is_bench},
        .is_jitter = {is_jitter},
        .is_baseline = {is_baseline},
        .tags = std::span{{{tags}}},
        .requirements = std::span{{{reqs}}},
        .skip_reason = {skip_reason},
        .should_skip = {should_skip},
        .fixture = {fixture},
        .fixture_lifetime = {lifetime},
        .suite = {suite},
        .acquire_fixture = {acquire}
    }},

)FMT";

inline constexpr std::string_view group_runner_ephemeral = R"FMT()FMT";
inline constexpr std::string_view group_runner_suite = R"FMT()FMT";
inline constexpr std::string_view group_runner_global = R"FMT()FMT";

inline constexpr std::string_view array_decl_empty = R"FMT(constexpr std::array<std::string_view, 0> {name}{{}};

)FMT";

inline constexpr std::string_view array_decl_nonempty = R"FMT(constexpr std::array<std::string_view, {count}> {name} = {{
{body}
}};

)FMT";

inline constexpr std::string_view forward_decl_line = R"FMT(void {name}();

)FMT";

inline constexpr std::string_view forward_decl_ns = R"FMT(namespace {scope} {{
{lines}}} // namespace {scope}

)FMT";

} // namespace gentest::codegen::tpl
