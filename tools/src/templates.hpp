// Embedded templates for code generation.
//
// These string constants define the entire output structure of the generated
// test implementation and its building blocks. They are consumed by the
// emitter (emit.cpp) and rendered via fmt::format (partials) or plain
// placeholder replacement (main). Keeping templates in one header makes them
// easy to locate, review, and change.
//
// Placeholders and where they apply:
// - Main file (test_impl):
//     {{INCLUDE_SOURCES}}, {{FORWARD_DECLS}}, {{TRAIT_DECLS}},
//     {{WRAPPER_IMPLS}}, {{CASE_INITS}}, {{GROUP_RUNNERS}},
//     {{RUN_GROUPS}}, {{ENTRY_FUNCTION}}
//   The emitter uses simple string replacement for these.
// - Partials (formatted with fmt::format):
//   wrapper_free:     {w}, {fn}
//   wrapper_free_fixtures: {w}, {fn}, {decls}, {setup}, {teardown}, {call}
//   wrapper_ephemeral:{w}, {fixture}, {method}
//   wrapper_stateful: {w}, {fixture}, {method}
//   case_entry:       {name}, {wrapper}, {file}, {line}, {tags}, {reqs},
//                     {skip_reason}, {should_skip}, {fixture}, {lifetime}, {suite}
//   group_runner_*:   {gid}, {fixture}, {count}, {idxs}
//   array_decl_*:     {name}; or {count}, {name}, {body}
//   forward_decl_*:   {name}; or {scope}, {lines}
//
// IMPORTANT: Partials are fed into fmt::format, so any literal braces that
// must appear in the generated C++ need to be doubled here (e.g. function
// bodies, initializer lists, random_device{{}}).

#pragma once

#include <string_view>

namespace gentest::codegen::tpl {

inline constexpr std::string_view test_impl = R"CPP(// This file is auto-generated by gentest_codegen.
// Do not edit manually.

#include <array>
#include <exception>
#include <string>
#include <fmt/core.h>
#include <fmt/color.h>
#include <cstdlib>
#include <random>
#include <algorithm>
#include <type_traits>
#include <span>
#include <string_view>
#include <vector>
#include <memory>
#include <chrono>
#include <fstream>
#include <map>
#include <filesystem>
#ifdef GENTEST_USE_BOOST_JSON
#  include <boost/json.hpp>
#endif
#ifdef GENTEST_USE_BOOST_UUID
#  include <boost/uuid/uuid.hpp>
#  include <boost/uuid/uuid_generators.hpp>
#  include <boost/uuid/uuid_io.hpp>
#endif

#include "gentest/runner.h"
#include "gentest/fixture.h"

// Include test sources so fixture types are visible for wrappers
{{INCLUDE_SOURCES}}

// Include generated mock implementations (requires sources/types to be visible)
{{INCLUDE_MOCK_IMPL}}

{{FORWARD_DECLS}}
{{ACCESSOR_DECLS}}
namespace {

{{TRAIT_DECLS}}

// Per-case invocation wrappers. All wrappers use a uniform signature
//   void(void* ctx)
// Free tests ignore ctx; ephemeral fixtures construct a new instance per call;
// shared fixtures expect ctx to point to the shared fixture instance.
template <typename T>
inline void gentest_maybe_setup(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureSetup, T>) t.setUp();
}

template <typename T>
inline void gentest_maybe_teardown(T& t) {
    if constexpr (std::is_base_of_v<gentest::FixtureTearDown, T>) t.tearDown();
}
{{WRAPPER_IMPLS}}

enum class FixtureLifetime {
    None,
    MemberEphemeral,
    MemberSuite,
    MemberGlobal,
};

using FixtureAccessor = void* (*)(std::string_view);

struct Case {
    std::string_view                  name;
    void (*fn)(void*);
    std::string_view                  file;
    unsigned                          line;
    std::span<const std::string_view> tags;
    std::span<const std::string_view> requirements;
    std::string_view                  skip_reason;
    bool                              should_skip;
    std::string_view                  fixture;        // empty for free tests
    FixtureLifetime                   fixture_lifetime;
    std::string_view                  suite;
    FixtureAccessor                   acquire_fixture;
};

constexpr std::array<Case, {{CASE_COUNT}}> kCases = {
{{CASE_INITS}}
};
} // namespace

namespace {
bool wants_list(std::span<const char*> args) {
    for (const auto* arg : args) {
        if (arg != nullptr && std::string_view(arg) == "--list") {
            return true;
        }
    }
    return false;
}

bool wants_shuffle(std::span<const char*> args) {
    for (const auto* arg : args) {
        if (arg != nullptr && std::string_view(arg) == "--shuffle-fixtures") {
            return true;
        }
    }
    return false;
}

std::uint64_t parse_seed(std::span<const char*> args) {
    for (std::size_t i = 0; i + 1 < args.size(); ++i) {
        if (args[i] != nullptr && std::string_view(args[i]) == "--seed") {
            if (args[i + 1]) {
                std::uint64_t v = 0;
                for (const char ch : std::string_view(args[i + 1])) {
                    if (ch < '0' || ch > '9') { v = 0; break; }
                    v = v * 10 + static_cast<std::uint64_t>(ch - '0');
                }
                if (v != 0) return v;
            }
        }
    }
    return 0;
}
} // namespace

namespace {
bool wants_help(std::span<const char*> args) {
    for (const auto* arg : args) if (arg && std::string_view(arg) == "--help") return true;
    return false;
}

bool wants_list_tests(std::span<const char*> args) {
    for (const auto* arg : args) if (arg && std::string_view(arg) == "--list-tests") return true;
    return false;
}

const char* get_arg_value(std::span<const char*> args, std::string_view prefix) {
    for (const auto* arg : args) {
        if (!arg) continue;
        std::string_view s(arg);
        if (s.rfind(prefix, 0) == 0) return arg + prefix.size();
    }
    return nullptr;
}

bool wildcard_match(std::string_view text, std::string_view pattern) {
    std::size_t ti = 0, pi = 0, star = std::string_view::npos, mark = 0;
    while (ti < text.size()) {
        if (pi < pattern.size() && (pattern[pi] == '?' || pattern[pi] == text[ti])) { ++ti; ++pi; continue; }
        if (pi < pattern.size() && pattern[pi] == '*') { star = pi++; mark = ti; continue; }
        if (star != std::string_view::npos) { pi = star + 1; ti = ++mark; continue; }
        return false;
    }
    while (pi < pattern.size() && pattern[pi] == '*') ++pi;
    return pi == pattern.size();
}

std::string join_span(std::span<const std::string_view> items, char sep) {
    std::string out;
    for (std::size_t i = 0; i < items.size(); ++i) {
        if (i != 0) out.push_back(sep);
        out.append(items[i]);
    }
    return out;
}
// Color handling
bool g_color_output = true;
bool wants_no_color(std::span<const char*> args) {
    for (const auto* arg : args) if (arg && std::string_view(arg) == "--no-color") return true;
    return false;
}
bool env_no_color() {
    const char* a = std::getenv("NO_COLOR");
    if (a && *a) return true;
    a = std::getenv("GENTEST_NO_COLOR");
    if (a && *a) return true;
    return false;
}
bool use_color(std::span<const char*> args) { return !wants_no_color(args) && !env_no_color(); }
// GitHub annotations
bool g_github_annotations = false;
bool wants_github_annotations(std::span<const char*> args) {
    for (const auto* arg : args) if (arg && std::string_view(arg) == "--github-annotations") return true;
    return false;
}
bool env_github_actions() {
    const char* a = std::getenv("GITHUB_ACTIONS");
    if (a && *a) return true;
    return false;
}
static inline std::string gha_escape(std::string_view s) {
    std::string out;
    out.reserve(s.size());
    for (char ch : s) {
        switch (ch) {
        case '%': out += "%25"; break;
        case '\r': out += "%0D"; break;
        case '\n': out += "%0A"; break;
        default: out.push_back(ch); break;
        }
    }
    return out;
}
} // namespace

namespace {
struct Counters { std::size_t executed = 0; int failures = 0; };

// Result and reporting support (enabled via --junit=<file>)
struct RunResult {
    bool                     skipped{false};
    double                   time_s{0.0};
    std::vector<std::string> failures;
    std::vector<std::string> logs;
};
struct ReportItem {
    std::string              suite;
    std::string              name;
    double                   time_s{0.0};
    bool                     skipped{false};
    std::string              skip_reason;
    std::vector<std::string> failures;
    std::vector<std::string> logs;
};
static bool                    g_record_results = false;
static std::vector<ReportItem> g_report_items;

static inline std::string xml_escape(std::string_view s) {
    std::string out;
    out.reserve(s.size());
    for (char ch : s) {
        switch (ch) {
        case '&': out += "&amp;"; break;
        case '"': out += "&quot;"; break;
        case '\'': out += "&apos;"; break;
        case '<': out += "&lt;"; break;
        case '>': out += "&gt;"; break;
        default: out.push_back(ch); break;
        }
    }
    return out;
}

RunResult execute_one(const Case& test, void* ctx, Counters& c) {
    RunResult rr;
    if (test.should_skip) {
        rr.skipped = true;
        if (!test.skip_reason.empty()) {
            if (g_color_output) fmt::print(fmt::fg(fmt::color::yellow), "[ SKIP ] {} :: {}\n", test.name, test.skip_reason);
            else fmt::print("[ SKIP ] {} :: {}\n", test.name, test.skip_reason);
        } else {
            if (g_color_output) fmt::print(fmt::fg(fmt::color::yellow), "[ SKIP ] {}\n", test.name);
            else fmt::print("[ SKIP ] {}\n", test.name);
        }
        return rr;
    }
    ++c.executed;
    auto ctxinfo = std::make_shared<gentest::detail::TestContextInfo>();
    ctxinfo->display_name = std::string(test.name);
    ctxinfo->active = true;
    gentest::detail::set_current_test(ctxinfo);
    bool threw = false;
    const auto start_tp = std::chrono::steady_clock::now();
    try {
        test.fn(ctx);
    } catch (const gentest::failure& err) {
        threw = true;
        ctxinfo->failures.push_back(std::string("FAIL() :: ") + err.what());
    } catch (const gentest::assertion&) {
        threw = true;
        // messages already recorded
    } catch (const std::exception& err) {
        threw = true;
        ctxinfo->failures.push_back(std::string("unexpected std::exception: ") + err.what());
    } catch (...) {
        threw = true;
        ctxinfo->failures.push_back("unknown exception");
    }
    ctxinfo->active = false;
    gentest::detail::set_current_test(nullptr);
    const auto end_tp = std::chrono::steady_clock::now();
    rr.time_s = std::chrono::duration<double>(end_tp - start_tp).count();
    rr.failures = ctxinfo->failures;
    rr.logs = ctxinfo->logs;

    if (!ctxinfo->failures.empty()) {
        ++c.failures;
        if (g_color_output) fmt::print(stderr, fmt::fg(fmt::color::red), "[ FAIL ] {} :: {} issue(s)\n", test.name, ctxinfo->failures.size());
        else fmt::print(stderr, "[ FAIL ] {} :: {} issue(s)\n", test.name, ctxinfo->failures.size());
        for (std::size_t i = 0; i < ctxinfo->failures.size(); ++i) {
            const auto& m = ctxinfo->failures[i];
            fmt::print(stderr, "    - {}\n", m);
            if (g_github_annotations) {
                std::string_view file = test.file;
                unsigned line = test.line;
                if (i < ctxinfo->failure_locations.size()) {
                    const auto& fl = ctxinfo->failure_locations[i];
                    if (!fl.file.empty() && fl.line > 0) { file = fl.file; line = fl.line; }
                }
                fmt::print("::error file={},line={},title={}::{}\n",
                           file,
                           line,
                           gha_escape(std::string(test.name)),
                           gha_escape(m));
            }
        }
    } else if (!threw) {
        if (g_color_output) fmt::print(fmt::fg(fmt::color::green), "[ PASS ] {}\n", test.name);
        else fmt::print("[ PASS ] {}\n", test.name);
    } else {
        // threw but no messages recorded: still a failure
        ++c.failures;
        if (g_color_output) fmt::print(stderr, fmt::fg(fmt::color::red), "[ FAIL ] {}\n", test.name);
        else fmt::print(stderr, "[ FAIL ] {}\n", test.name);
    }
    return rr;
}

inline void execute_and_record(const Case& test, void* ctx, Counters& c) {
    RunResult rr = execute_one(test, ctx, c);
    if (!g_record_results) return;
    ReportItem item;
    item.suite       = std::string(test.suite);
    item.name        = std::string(test.name);
    item.time_s      = rr.time_s;
    item.skipped     = rr.skipped;
    item.skip_reason = std::string(test.skip_reason);
    item.failures    = std::move(rr.failures);
    item.logs        = std::move(rr.logs);
    g_report_items.push_back(std::move(item));
}

inline void write_junit(const char* path) {
    if (!path) return;
    std::size_t total_tests = g_report_items.size();
    std::size_t total_fail = 0;
    std::size_t total_skip = 0;
    double total_time = 0.0;
    for (const auto& it : g_report_items) {
        total_fail += it.failures.empty() ? 0 : 1;
        total_skip += it.skipped ? 1 : 0;
        total_time += it.time_s;
    }
    std::ofstream f(path, std::ios::binary);
    if (!f) return;
    auto fmtd = [](double v){ std::ostringstream os; os.setf(std::ios::fixed); os.precision(6); os << v; return os.str(); };
    f << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    f << "<testsuites tests=\"" << total_tests << "\" failures=\"" << total_fail << "\" skipped=\"" << total_skip << "\" time=\"" << fmtd(total_time) << "\">\n";
    // group by suite
    std::map<std::string, std::vector<const ReportItem*>> by_suite;
    for (const auto& it : g_report_items) by_suite[it.suite].push_back(&it);
    for (const auto& [suite, vec] : by_suite) {
        std::size_t failures = 0, skipped = 0; double time = 0.0;
        for (auto* p : vec) { failures += p->failures.empty() ? 0 : 1; skipped += p->skipped ? 1 : 0; time += p->time_s; }
        f << "  <testsuite name=\"" << xml_escape(suite) << "\" tests=\"" << vec.size() << "\" failures=\"" << failures << "\" skipped=\"" << skipped << "\" time=\"" << fmtd(time) << "\">\n";
        for (auto* p : vec) {
            f << "    <testcase classname=\"" << xml_escape(suite) << "\" name=\"" << xml_escape(p->name) << "\" time=\"" << fmtd(p->time_s) << "\">\n";
            if (p->skipped) {
                if (!p->skip_reason.empty()) f << "      <skipped message=\"" << xml_escape(p->skip_reason) << "\"/>\n";
                else f << "      <skipped/>\n";
            } else if (!p->failures.empty()) {
                const std::string& first = p->failures.front();
                f << "      <failure message=\"" << xml_escape(first) << "\">\n<![CDATA[\n";
                for (const auto& msg : p->failures) f << msg << "\n";
                f << "]]></failure>\n";
            }
            f << "    </testcase>\n";
        }
        f << "  </testsuite>\n";
    }
    f << "</testsuites>\n";
}

inline void write_allure(const char* dir_path) {
    if (!dir_path) return;
    namespace fs = std::filesystem;
    std::error_code ec;
    fs::create_directories(fs::path(dir_path), ec);
    // Approximate start/stop from duration around now
    const auto now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
    std::size_t idx = 0;
    auto uuid_v4 = []() {
#ifdef GENTEST_USE_BOOST_UUID
        const auto id = boost::uuids::random_generator()();
        return boost::uuids::to_string(id);
#else
        std::array<unsigned char, 16> b{};
        std::random_device rd;
        for (auto &x : b) x = static_cast<unsigned char>(rd());
        // Set version (4) and variant (10xxxxxx)
        b[6] = static_cast<unsigned char>((b[6] & 0x0F) | 0x40);
        b[8] = static_cast<unsigned char>((b[8] & 0x3F) | 0x80);
        auto nib = [](unsigned char v) -> char {
            static const char* kHex = "0123456789abcdef";
            return kHex[v & 0x0F];
        };
        std::string s;
        s.resize(36);
        int pos = 0;
        auto emit_byte = [&](unsigned char v) {
            s[pos++] = nib((v >> 4) & 0x0F);
            s[pos++] = nib(v & 0x0F);
        };
        for (int i = 0; i < 16; ++i) {
            if (i == 4 || i == 6 || i == 8 || i == 10) s[pos++] = '-';
            emit_byte(b[i]);
        }
        return s;
#endif
    };
    auto json_escape = [](std::string_view s) {
        std::string out;
        out.reserve(s.size());
        for (char ch : s) {
            switch (ch) {
            case '\\': out += "\\\\"; break;
            case '"': out += "\\\""; break;
            case '\n': out += "\\n"; break;
            case '\r': out += "\\r"; break;
            case '\t': out += "\\t"; break;
            default: out.push_back(ch); break;
            }
        }
        return out;
    };
    for (const auto& it : g_report_items) {
        const auto duration_ms = static_cast<long long>(it.time_s * 1000.0);
        const auto start_ms = now_ms - duration_ms;
        const auto stop_ms = now_ms;
        const std::string base = "result-" + std::to_string(idx++);
        const std::string filename = (fs::path(dir_path) / (base + "-result.json")).string();
#ifdef GENTEST_USE_BOOST_JSON
        const char* status = it.skipped ? "skipped" : (it.failures.empty() ? "passed" : "failed");
        boost::json::object root;
        root["uuid"] = uuid_v4();
        root["name"] = it.name;
        root["fullName"] = it.suite + "/" + it.name;
        root["status"] = status;
        root["stage"] = "finished";
        root["start"] = static_cast<std::int64_t>(start_ms);
        root["stop"]  = static_cast<std::int64_t>(stop_ms);
        boost::json::array labels;
        labels.emplace_back(boost::json::object{{"name","suite"},{"value",it.suite}});
        root["labels"] = std::move(labels);
        if (!it.failures.empty()) {
            std::string all;
            for (const auto& m : it.failures) { all.append(m); all.push_back('\n'); }
            root["statusDetails"] = boost::json::object{{"message", it.failures.front()},{"trace", all}};
        }
        if (!it.failures.empty() && !it.logs.empty()) {
            const std::string logs_name = base + "-attachment.txt";
            const std::string logs_path = (fs::path(dir_path) / logs_name).string();
            std::ofstream lf(logs_path, std::ios::binary);
            if (lf) { for (const auto& line : it.logs) { lf << line << "\n"; } }
            boost::json::array attachments;
            attachments.emplace_back(boost::json::object{{"name","logs"},{"source",logs_name},{"type","text/plain"}});
            root["attachments"] = std::move(attachments);
        }
        std::ofstream f(filename, std::ios::binary);
        if (!f) continue;
        f << boost::json::serialize(root) << '\n';
#else
        std::ofstream f(filename, std::ios::binary);
        if (!f) continue;
        const char* status = it.skipped ? "skipped" : (it.failures.empty() ? "passed" : "failed");
        std::string first_msg = it.failures.empty() ? std::string() : it.failures.front();
        // Minimal Allure 2 result JSON
        f << "{\n";
        const std::string uuid = uuid_v4();
        f << "  \"uuid\": \"" << json_escape(uuid) << "\",\n";
        f << "  \"name\": \"" << json_escape(it.name) << "\",\n";
        f << "  \"fullName\": \"" << json_escape(it.suite + "/" + it.name) << "\",\n";
        f << "  \"status\": \"" << status << "\",\n";
        f << "  \"stage\": \"finished\",\n";
        // Allure 2 uses top-level start/stop; time object is optional and ignored by readers.
        f << "  \"start\": " << start_ms << ",\n";
        f << "  \"stop\": " << stop_ms << ",\n";
        f << "  \"labels\": [ { \"name\": \"suite\", \"value\": \"" << json_escape(it.suite) << "\" } ]";
        bool wrote_details = false;
        if (!it.failures.empty()) {
            f << ",\n  \"statusDetails\": { \"message\": \"" << json_escape(first_msg) << "\", \"trace\": \"";
            std::string all;
            for (const auto& m : it.failures) { all.append(m); all.push_back('\n'); }
            f << json_escape(all) << "\" }";
            wrote_details = true;
        }
        // Attach logs as an attachment when failing and logs exist
        if (!it.failures.empty() && !it.logs.empty()) {
            const std::string logs_name = base + "-attachment.txt";
            const std::string logs_path = (fs::path(dir_path) / logs_name).string();
            std::ofstream lf(logs_path, std::ios::binary);
            if (lf) { for (const auto& line : it.logs) { lf << line << "\n"; } }
            f << (wrote_details ? ",\n" : ",\n")
              << "  \"attachments\": [ { \"name\": \"logs\", \"source\": \"" << json_escape(logs_name) << "\", \"type\": \"text/plain\" } ]\n";
        } else {
            f << "\n";
        }
        f << "}\n";
#endif
    }
}
} // namespace

// Group runners for fixture-based tests.
// Generated per-fixture group; invoked after free tests.
{{GROUP_RUNNERS}}

auto {{ENTRY_FUNCTION}}(std::span<const char*> args) -> int {
    g_color_output = use_color(args);
    g_report_items.clear();
    g_github_annotations = wants_github_annotations(args) || env_github_actions();
    if (wants_help(args)) {
        fmt::print("gentest v{{VERSION}}\n");
        fmt::print("Usage: [options]\n");
        fmt::print("  --help                Show this help\n");
        fmt::print("  --list-tests          List test names (one per line)\n");
        fmt::print("  --list                List tests with metadata\n");
        fmt::print("  --run-test=<name>     Run a single test by exact name\n");
        fmt::print("  --filter=<pattern>    Run tests matching wildcard pattern (*, ?)\n");
        fmt::print("  --no-color            Disable colorized output (or set NO_COLOR/GENTEST_NO_COLOR)\n");
        fmt::print("  --github-annotations  Emit GitHub Actions annotations (::error ...) on failures\n");
        fmt::print("  --junit=<file>        Write JUnit XML report to file\n");
        fmt::print("  --allure-dir=<dir>    Write Allure result JSON files into directory\n");
        fmt::print("  --shuffle-fixtures    Shuffle order within each fixture group\n");
        fmt::print("  --seed N              RNG seed used with --shuffle-fixtures\n");
        return 0;
    }
    if (wants_list_tests(args)) {
        for (const auto& t : kCases) fmt::print("{}\n", t.name);
        return 0;
    }
    if (wants_list(args)) {
        for (const auto& test : kCases) {
            std::string sections;
            if (!test.tags.empty() || !test.requirements.empty() || test.should_skip) {
                sections.push_back(' ');
                sections.push_back('[');
                bool first = true;
                if (!test.tags.empty()) {
                    sections.append("tags=");
                    sections.append(join_span(test.tags, ','));
                    first = false;
                }
                if (!test.requirements.empty()) {
                    if (!first) sections.push_back(';');
                    sections.append("requires=");
                    sections.append(join_span(test.requirements, ','));
                    first = false;
                }
                if (test.should_skip) {
                    if (!first) sections.push_back(';');
                    sections.append("skip");
                    if (!test.skip_reason.empty()) { sections.push_back('='); sections.append(test.skip_reason); }
                }
                sections.push_back(']');
            }
            fmt::print("{}{} ({}:{})\n", test.name, sections, test.file, test.line);
        }
        return 0;
    }
    Counters counters;
    const char* junit_path = get_arg_value(args, "--junit=");
    const char* allure_dir = get_arg_value(args, "--allure-dir=");
    g_record_results = (junit_path != nullptr) || (allure_dir != nullptr);

    // Selection support: --run-test / --filter
    const char* run_exact = get_arg_value(args, "--run-test=");
    const char* filter_pat = get_arg_value(args, "--filter=");
    if (run_exact || filter_pat) {
        std::vector<std::size_t> sel;
        if (run_exact) {
            for (std::size_t i = 0; i < kCases.size(); ++i) if (kCases[i].name == run_exact) { sel.push_back(i); break; }
            if (sel.empty()) { fmt::print(stderr, "Test not found: {}\n", run_exact); return 1; }
        } else {
            for (std::size_t i = 0; i < kCases.size(); ++i) if (wildcard_match(kCases[i].name, filter_pat)) sel.push_back(i);
            if (sel.empty()) { fmt::print("Executed 0 test(s).\n"); return 0; }
        }
        // Free tests
        for (auto i : sel) {
            const auto& t = kCases[i];
            if (!t.fixture.empty()) continue;
            execute_and_record(t, nullptr, counters);
        }
        // Fixture tests honour lifetime semantics during selection as well.
        const bool         shuffle = wants_shuffle(args);
        const std::uint64_t seed    = parse_seed(args);
        // Group by fixture name
        std::vector<std::pair<std::string_view, std::vector<std::size_t>>> groups;
        for (auto i : sel) { const auto& t = kCases[i]; if (t.fixture.empty()) continue; auto it = std::find_if(groups.begin(), groups.end(), [&](auto& g){return g.first==t.fixture;}); if (it==groups.end()) groups.push_back({t.fixture,{i}}); else it->second.push_back(i); }
        for (std::size_t gid = 0; gid < groups.size(); ++gid) {
            auto order = groups[gid].second;
            if (shuffle && order.size() > 1) { std::mt19937_64 rng(seed ? (seed + gid) : std::mt19937_64::result_type(std::random_device{}())); std::shuffle(order.begin(), order.end(), rng); }
            for (auto i : order) {
                const auto& test = kCases[i];
                void* ctx = nullptr;
                switch (test.fixture_lifetime) {
                case FixtureLifetime::MemberSuite:
                case FixtureLifetime::MemberGlobal:
                    if (test.acquire_fixture) {
                        ctx = test.acquire_fixture(test.suite);
                    }
                    break;
                case FixtureLifetime::MemberEphemeral:
                case FixtureLifetime::None:
                default:
                    ctx = nullptr;
                    break;
                }
                execute_and_record(test, ctx, counters);
            }
        }
        if (counters.failures == 0) {
            if (g_color_output) fmt::print(fmt::fg(fmt::color::green), "Executed {} test(s).\n", counters.executed);
            else fmt::print("Executed {} test(s).\n", counters.executed);
        } else {
            if (g_color_output) fmt::print(stderr, fmt::fg(fmt::color::red), "Executed {} test(s) with {} failure(s).\n", counters.executed, counters.failures);
            else fmt::print(stderr, "Executed {} test(s) with {} failure(s).\n", counters.executed, counters.failures);
        }
        if (g_record_results) { if (junit_path) write_junit(junit_path); if (allure_dir) write_allure(allure_dir); }
        return counters.failures == 0 ? 0 : 1;
    }

    // Default path: run all tests with built-in grouping
    for (const auto& t : kCases) { if (!t.fixture.empty()) continue; execute_and_record(t, nullptr, counters); }
    const bool         shuffle = wants_shuffle(args);
    const std::uint64_t seed    = parse_seed(args);
    {{RUN_GROUPS}}
    if (counters.failures == 0) {
        if (g_color_output) fmt::print(fmt::fg(fmt::color::green), "Executed {} test(s).\n", counters.executed);
        else fmt::print("Executed {} test(s).\n", counters.executed);
    } else {
        if (g_color_output) fmt::print(stderr, fmt::fg(fmt::color::red), "Executed {} test(s) with {} failure(s).\n", counters.executed, counters.failures);
        else fmt::print(stderr, "Executed {} test(s) with {} failure(s).\n", counters.executed, counters.failures);
    }
    if (g_record_results) { if (junit_path) write_junit(junit_path); if (allure_dir) write_allure(allure_dir); }
    return counters.failures == 0 ? 0 : 1;
}

auto {{ENTRY_FUNCTION}}(int argc, char** argv) -> int {
    std::vector<const char*> args;
    args.reserve(static_cast<std::size_t>(argc));
    for (int i = 0; i < argc; ++i) {
        args.push_back(argv[i]);
    }
    return {{ENTRY_FUNCTION}}(std::span<const char*>{args.data(), args.size()});
}
)CPP";

inline constexpr std::string_view wrapper_free = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    {invoke}
}}

)FMT";

inline constexpr std::string_view wrapper_free_fixtures = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
{decls}{setup}    {invoke}
{teardown}}}

)FMT";

inline constexpr std::string_view wrapper_ephemeral = R"FMT(static void {w}(void* ctx_) {{
    (void)ctx_;
    {fixture} fx_;
    gentest_maybe_setup(fx_);
    {invoke}
    gentest_maybe_teardown(fx_);
}}

)FMT";

inline constexpr std::string_view wrapper_stateful = R"FMT(static void {w}(void* ctx_) {{
    auto* fx_ = static_cast<{fixture}*>(ctx_);
    gentest_maybe_setup(*fx_);
    {invoke}
    gentest_maybe_teardown(*fx_);
}}

)FMT";

inline constexpr std::string_view case_entry = R"FMT(    Case{{
        "{name}",
        &{wrapper},
        "{file}",
        {line},
        std::span{{{tags}}},
        std::span{{{reqs}}},
        {skip_reason},
        {should_skip},
        {fixture},
        {lifetime},
        {suite},
        {acquire}
    }},

)FMT";

inline constexpr std::string_view group_runner_ephemeral =
    R"FMT(static void gentest_run_group_{gid}(bool shuffle_, std::uint64_t seed_, Counters& counters_) {{
    using Fixture = {fixture};
    const std::array<std::size_t, {count}> idxs_ = {{ {idxs} }};
    std::vector<std::size_t> order_(idxs_.begin(), idxs_.end());
    if (shuffle_ && order_.size() > 1) {{ std::mt19937_64 rng_(seed_ ? (seed_ + {gid}) : std::mt19937_64::result_type(std::random_device{{}}())); std::shuffle(order_.begin(), order_.end(), rng_); }}
    for (auto i_ : order_) {{ execute_and_record(kCases[i_], nullptr, counters_); }}
}}

)FMT";

inline constexpr std::string_view group_runner_suite = R"FMT(static void* gentest_access_fixture_{gid}(std::string_view suite_) {{
    using Fixture = {fixture};
    struct Entry {{ std::string_view key; std::unique_ptr<Fixture> instance; }};
    static std::vector<Entry> fixtures_;
    for (auto& entry : fixtures_) {{ if (entry.key == suite_) return entry.instance.get(); }}
    fixtures_.push_back(Entry{{suite_, std::make_unique<Fixture>()}});
    return fixtures_.back().instance.get();
}}

static void gentest_run_group_{gid}(bool shuffle_, std::uint64_t seed_, Counters& counters_) {{
    using Fixture = {fixture};
    const std::array<std::size_t, {count}> idxs_ = {{ {idxs} }};
    std::vector<std::size_t> order_(idxs_.begin(), idxs_.end());
    if (shuffle_ && order_.size() > 1) {{ std::mt19937_64 rng_(seed_ ? (seed_ + {gid}) : std::mt19937_64::result_type(std::random_device{{}}())); std::shuffle(order_.begin(), order_.end(), rng_); }}
    for (auto i_ : order_) {{
        auto* fx_ = static_cast<Fixture*>(gentest_access_fixture_{gid}(kCases[i_].suite));
        execute_and_record(kCases[i_], fx_, counters_);
    }}
}}

)FMT";

inline constexpr std::string_view group_runner_global = R"FMT(static void* gentest_access_fixture_{gid}(std::string_view) {{
    using Fixture = {fixture};
    static Fixture fx_;
    return &fx_;
}}

static void gentest_run_group_{gid}(bool shuffle_, std::uint64_t seed_, Counters& counters_) {{
    using Fixture = {fixture};
    const std::array<std::size_t, {count}> idxs_ = {{ {idxs} }};
    std::vector<std::size_t> order_(idxs_.begin(), idxs_.end());
    if (shuffle_ && order_.size() > 1) {{ std::mt19937_64 rng_(seed_ ? (seed_ + {gid}) : std::mt19937_64::result_type(std::random_device{{}}())); std::shuffle(order_.begin(), order_.end(), rng_); }}
    auto* fx_ = static_cast<Fixture*>(gentest_access_fixture_{gid}(std::string_view{{}}));
    for (auto i_ : order_) {{ execute_and_record(kCases[i_], fx_, counters_); }}
}}

)FMT";

inline constexpr std::string_view array_decl_empty = R"FMT(constexpr std::array<std::string_view, 0> {name}{{}};

)FMT";

inline constexpr std::string_view array_decl_nonempty = R"FMT(constexpr std::array<std::string_view, {count}> {name} = {{
{body}
}};

)FMT";

inline constexpr std::string_view forward_decl_line = R"FMT(void {name}();

)FMT";

inline constexpr std::string_view forward_decl_ns = R"FMT(namespace {scope} {{
{lines}}} // namespace {scope}

)FMT";

} // namespace gentest::codegen::tpl
